[{"title":"ES6重要知识总结","date":"2017-08-05T14:36:14.000Z","path":"2017/08/05/ES6重要知识总结/","text":"1 let和const 共同点： 不存在变量提升，作用在块级作用域，不允许重复声明。 不同点 const必须在声明的时候就赋值，声明过后不能重新赋值。 2 解构赋值 通过解析解构来赋值，和就够相相应的赋值形式，存在一下好处： (1) 指定默认值（函数，对象等）； (2) 不引入其他变量方便的交换变量的值； (3) 方便的接受函数的返回值（当返回是对象的时候） (4) 是json的处理更加简洁 (5) 制定输入模块的方法 3 字符窜扩展 使用 `` 代替 “”， 使用${}在字符窜中嵌入变量，不再使用+号连接字符窜。 4 函数扩展 参数默认值的设置： es6可以直接对函数的参数设置默认值，eg: 123456789function test(x=1,y=2) &#123; console.log(x,y);&#125;test(); //1,2test(4,5); //4,5test(4); //4,2test( ,5) //报错test(undefined,5); //1,5// 默认参数一般放在最后，只有最后一个默认参数在传参的时候可以省略，否则会报错， 如果想要使用默认参数，可以传入“unfefined”； length属性失真： 制定了默认参数后，函数的length属性将发生变化，length变为第一个默认参数之前的参数个数，eg： 123(function(x=1,y=2)&#123;&#125;).length; //0(function(x,y,z=1)&#123;&#125;).length; //2(function(x,y=1,z,m=2)&#123;&#125;).length; //1 作用域（参数作用域）： 指定了默认参数后，参数会形成一个单独的作用域，eg: 12345678910111213const x=3;function test(x,y=x) &#123; console.log(y);&#125;test(4); // 4//在参数空间内，y的值由x赋给，此时x的值是4，所以y输出4；const z = 4;function test1(z=z)&#123; console.log(z);&#125;test1(); // ReferenceError: z is not defined//在调用test1()的时候没用传参，这时参数z的值并没有从全局变量中去寻找，可见参数作用域是一个特定的作用域。 箭头函数 : 箭头函数是使用 “=&gt;“的一种函数写法，可以使函数的书写更加简介，它具有以下特点： (1) 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分，eg： 1234567891011const showName = () =&gt; \"izqcool\";//等价于const showName = fuction() &#123; return \"izqcool\";&#125;const add = (num1,num2) =&gt; num1+num2;//等价于const add = function(num1,num2) &#123; return num1+num2;&#125; (2) 函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回，eg： 1234const add = (num1,num2) =&gt; &#123; const sum = num1+num2; return sum;&#125;; (3) 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，eg： 1const getItem = (id) =&gt; (&#123;id:id,name:\"izqcool\"&#125;); (4) 可以与变量解构结合使用： 12345const getName = (&#123;firstName,lastName&#125;) =&gt; firsrName + \" \" + lastName;//等价于const getName = function(person)&#123; return person.firstName + \" \" + person.lastName;&#125; (5) 箭头函数的this对象: （箭头函数的this对象指向的是定义时的对象，而不是调用的对象）,eg： 123456789101112131415161718function Timer() &#123; this.s1 = 0; this.s2 = 0; setInterval(() =&gt; this.s1++,1000); setInterval(function()&#123; this.s2++; &#125;,1000)&#125;const timer = new Timer();setTimeout(()=&gt;&#123; console.log(\"s1:\"+timer.s1);&#125;,3100);//s1:3setTimeout(()=&gt;&#123; console.log(\"s2:\"+timer.s2);&#125;,3100);//s2:0 ###5 module 语法及加载机制： 1 输入模块 import1234567import &#123; stat, exists, readFile &#125; from 'fs';//从fs模块加载以上3个方法，其余的不加载（如果有） 加载方式为静态加载（编译时加载）import &#123; stat as xxx &#125; from './fs';//将stat定义为别名xxximport * as xxx from './fs';//加载所有并定义为别名xxx 1.2 模块对外接口 export12345678910111213141516const A = 1;const B = 2;const C = 3;//输出A,B,Bexport &#123;A,B,C&#125;;//指定别名输出A,B,Cexport &#123; A as nameA, B as nameB, C as nameC&#125;;//默认输出(只能有一个)export default 2 加载机制 es6的模块引用是动态加载的，import加载的是值引用（不是值的拷贝），脚本执行时，根据引用到被加载的模块去取值，被加载模块内部的变化会体现在加载的模块里，所以说是“活的”。","tags":[{"name":"ES6 总结","slug":"ES6-总结","permalink":"http://izqcool.com/tags/ES6-总结/"}]},{"title":"2017,新的开始","date":"2017-01-01T14:16:26.000Z","path":"2017/01/01/2017-新的开始/","text":"写在开头： 阳历新年的第一天，很有必要写点东西来开始我人生中新的一年，因为我知道，这必然是不平凡的一年，我希2017年我能过得更好，当我在年终总结的时候，我没有遗憾，对得起我人生中的这充满期盼的一年。 回首过去：2016年过得平平淡淡，大部分时间和以前都差不多，九月和十月是唯一的插曲，身边的人大多数要么在努力找工作，要么奋斗在图书馆的考研路上。自己还是比较幸运，没用太多的时间找到了自己想要的工作，虽然不是最理想，但也说得上满意。如果说有遗憾，那就是对自己要其实的不高，浪费了太多的时间，没有是自己变得优秀。 展望未来：2017注定会有很多不舍和波折，对离校的不舍，多社会的适应，我不敢去奢求每一件事都完美，但是我可以让自己变得更好： 1. 尽可能让自己的github多绿一些 2. 多看书，升华自己 3. 对得起身边的每一个人 最后，对自己说一句，加油，期待2017愈发优秀的自己！！！","tags":[{"name":"记录 生活","slug":"记录-生活","permalink":"http://izqcool.com/tags/记录-生活/"}]},{"title":"Js中this关键字","date":"2016-09-11T02:52:03.000Z","path":"2016/09/11/js中this关键字/","text":"js中的this关键字的只想问题是容易出错地方，很多初学者在面对this关键字时摸不着头脑。其实this关键字并不是无章可循，弄清楚这个函数或者方法是谁调用的，this的指向就是谁，下面给出常见的几种调用方法。 函数的调用方式有以下几种： 普通函数调用 作为方法来调用 作为构造函数来调用 使用apply/call方法来调用 Function.prototype.bind方法 es6箭头函数 普通函数的调用：12345678function test() &#123; this.name = \"izqcool\"; console.log(this); console.log(this.name); &#125;test(); // 输出为： Window izqcoolwindow.test(); // 输出为： Window izqcoolconsole.log(window.name); //izqcool 上面的代码test函数先作为普通，实际上test是作为全局对象window的一个方法来调用，即window.test(),所以二者输出结果完全相同，此时是window对象调用了test方法，test函数中的this就指向window,test函数中的this.name=”izqcool”等价于window.name = “izqcool”,所以window获得了name的值为izqcool的属性； 将代码作以下修改：12345vae name = \"izqcool_test\";function test() &#123; console.log(this.name);&#125;test(); //输出: izqcool_test 同样这个地方test作为window的方法来调用，在代码的一开始定义了一个全局变量name，值为izqcool_test,它相当于window的一个属性,即window.name=”izqcool_test”,又因为在调用test的时候this是指向window的，因此这里会输出izqcool_test. 作为方法调用:严格来说，上面的示例test函数也是作为方法来调用的，test函数是window的方法，this指向了window。 我们再来看一个直观的例子：1234567891011121314var name = \"izqcool_test\";var test = &#123; name : \"izqcool\", showName : function() &#123; console.log(this.name); &#125;&#125;;test.showName(); //输出: izqcool//此处是test对象调用showName方法，所以this关键字是指向test对象的，test对象的name值为所以输出izqcoolvar showName_another = test.showName;showName_another(); //输出： izqcool_test //这里将test.showName方法赋给showName_another变量，此时showName_another变量相当于window对象的一个属性，因此showName_another()执行的时候相当于window.showName_another,即window对象调用showName_another这个方法，所以this关键字指向window,输出为izqcool_test 再换一种形式：1234567891011121314var test_1 = &#123; name : \"izqcool_1\", showName : function() &#123; console.log(this.name); &#125;&#125;;var test_2 = &#123; name : \"izqcool_2\", sayName : test_1.showName;&#125;;test_2.sayName(); //输出: izqcool_2;//虽然showName这个方法是在test_1中定义的，但是缺是被test_2调用的，可见在哪里声明并不重要，关键还是要看被谁调用。 作为构造函数调用:1234567891011function Test(name) &#123; this.name = name;&#125;var test_1 = Test(\"izqcool\");console.log(test_1.name); // 输出： 报错console.log(window.name); // 输出： izqcool//上述代码没有进行new操作符，将Test函数直接调用，相当于window对象调用Test(),this指向window,所以window.name输出为izqcool。var test_2 = new Test(\"izqcool\");consoel.log(test_2.name); //输出: izqcool 关于构造函数，我会在之后写一篇文章详细介绍。 call/apply方法的调用call/apply方法可以用来改变this关键字的指向： Object.method.apply(AnotherObj,arguments);123456789var name = \"izqcool\";var Test = &#123; name : \"izqcool_test\", showName : function() &#123; console.log(this.name); &#125;&#125;;Test.showName.call(); //输出： izqcool //call方法的第一个参数为空时，默认为window,使用call方法后，showName方法内的this指向了window，故输出为izqcool. Function.prototype.bind()方法123456789101112var name = \"izqcool\";function Test(name) &#123; this.name = name; this.sayName = function() &#123; setTimeout(function()&#123; console.log(\"my name is:\" + this.name); &#125;,100); &#125;&#125;var test = new Test(\"izqcool_test\");test.sayName(); //输出: my name is: izqcool//这里的setTimeout()函数，相当于window.setTimeout(),由window这个全局对象调用，因此输出为izqcool,而不是izqcool_test。 那么如何才能实现输出izqcool_test呢？123456789101112var name = \"izqcool\";function Test(name) &#123; this.name = name; this.sayName = function() &#123; setTimeout(function()&#123; console.log(\"my name is:\" + this.name); &#125;.bind(this),100); //这里使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Test对象 &#125;&#125;var test = newTest(\"izqcool_test\");test.sayName(); //输出: my name is: izqcool_test//这里的setTimeout()函数，相当于window.setTimeout(),由window这个全局对象调用，因此输出为izqcool,而不是izqcool_test。 需要注意的是： setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。在《javascript高级程序设计》当中，写到：“超时调用的代码(setTimeout)都是在全局作用域中执行的，因此函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined”。本文都是在非严格模式下的情况。 上面的例子也可以写成这样：12345678910111213var name = \"izqcool\";function Test(name) &#123; var that = this; this.name = name; this.sayName = function() &#123; setTimeout(function()&#123; console.log(\"my name is:\" + that.name); &#125;,100); &#125;&#125;var test = newTest(\"izqcool_test\");test.sayName(); //输出: my name is: izqcool_test//先将this值赋给了that，这样that保存的是Test对象，访问that.name时，取到的值是Test.name的值。 ES6箭头函数：在ES6中，this指向是固定的，始终指向外部对象，因为箭头函数没有this,因此它自身不能进行new实例化,同时也不能使用call, apply, bind等方法来改变this的指向 12345678910111213141516function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100); //输出 s1: 3setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100); //输出 s2: 0 面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。 结语：js中this的指向问题我们不要关注函数是在哪里申明的，而要看是在哪里调用的，在平时的编码过程中多分析，多测试，掌握起来应该不是什么难事。","tags":[{"name":"js","slug":"js","permalink":"http://izqcool.com/tags/js/"}]},{"title":"暑期总结","date":"2016-08-28T06:38:14.000Z","path":"2016/08/28/暑期总结/","text":"不知不觉间大三暑假马上就要结束了，原本打算暑假找一份实习锻炼下自己这一年多的学习成果，可是由于一些原因最终没能出去实习，实在是很遗憾。但是多少还是有一些收获，接受过几次面试，对自己目前的能力有了比较清晰的认识，记录下来，鞭策自己。 印象最深的两次面试 北京某公司 一家创业公司，前端团队人数不多，虽然没去公司面试，但是面试官和负责任，可以看出面试内容是经过精心准备的，考察的知识点很细节。这次面试让我深刻认识到自己的基础知识还存在很多的不足，尤其是CSS部分。另外，面试官给出了很多自己学习的经验，推荐了很不错的方法，令我受益匪浅。 阿里 面的是阿里的内推，阿里的面试很少问细节的东西，更多的是对技术的理解。 第一次接面试电话的时候，面试官只是了解了基本情况，然后让我写一份自己的技术栈架整理和自己的学习路线，然后第二天针对自己的整理进行面试。当时我的整理中提到了vue和avalon框架，面试官针对框架的之间差异提问，让我对比两个框架的特点，一些功能的实现方式，我回答的不是很理想，面试官建议我去多看一些源码，学会归纳对比，要对自己的技术栈有一个明确的认识。 两次的面试各有偏重点，但对我今后的学习却很有帮助。今后要多谢博客，记录整理自己所学，谨以此篇开始记录之路。","tags":[{"name":"总结","slug":"总结","permalink":"http://izqcool.com/tags/总结/"}]},{"title":"Js作用域与作用域链","date":"2016-05-13T12:50:59.000Z","path":"2016/05/13/js作用域与作用域链/","text":"导语： 在JavaScript的学习中，作用域和作用域链是非常重要的两个基础概念，理解好这两个概念对我们掌握变量提升、闭包等概念有很大的帮助。 作用域： 概念： 变量和函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。 分类： 全局作用域：（在代码的任何地方都可以访问到）： 1.所有未定义直接赋值的变量会自动生命为全局作用域 2.所有window对象的属性 局部作用域：（只用在固定的代码片段中可以访问，常见于函数内部，习惯叫做函数作用域） 注意： js里是是没有块级作用域的，定义在for()循环内的变量能够在for()循环外访问到：1234for(var i=0;i&lt;10;i++) &#123; var color = \"blue\";&#125; console.log(color); 输出结果为blue,可见可以访问到代码块内声明的变量。 作用域链： 全局变量在程序中始终是有定义的。局部变量在声明它的函数体内以及它所嵌套的函数内始终是有定义的。这句话准确的定义了作用域链，但是对于初学者来说会有点难以理解。下面是我对作用域链的简单理解： JavaScript有一个内部属性称为Scope，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 如下面这张图： 1，2，3分别表示3个不同的作用域，在这3个作用域中，他们彼此独立，互不干扰，函数1不能访问定义在函数2和3中的变量，也就是说定义在函数内部的变量只对这个的函数生效，其他函数是无法使用这个变量的。（当然，这只是针对相互对立的函数，嵌套函数不是这样）。 对于含有嵌套关系的函数，像上图3中这样，就会遵循作用域链规则，我们把它单独拿出来讲解，如下图所示： 对应的，我们看下面这段代码： 1234567891011121314151617181920var global1 = 'global1';var global2 = 'global2';function fn1() &#123; var a = 1; function fn2() &#123; var b = 2; function fn3() &#123; var c = 3; var global2 = 'another global2'; console.log(c); console.log(b); console.log(a); console.log(global1); console.log(global2); &#125; fn3(); &#125; fn2();&#125;fn1(); 上面代码对应的输出结果依次为3，2，1，global1，another global2; 可以看到，在最内层的函数中，我们可以访问外层定义的变量。它的工作过程基于作用域链，在嵌套函数中，当变量本层函数中未定义时，会向外层寻找，若找到就结束，使用找到的变量，找不到就继续，当在全局变量中还是找不到时，就会报错。我将这种机制称为由内而外，就近原则，由内而外就是上图所的向外层寻找，函数fn3可以找到外层函数fn2定义的变量b，而反过来函数fn2却不能使用变量c；就近原则和我们在英语学习中的就近原则是一个意思，就是选择最近的一个，上面的例子中，分别在函数fn3和全局对象中定义了global2,但是在由内而外寻找时，最先寻找的是在fn3内定义的，所以就终止寻找，最终输出的global2的结果为another global2而不是global2。","tags":[{"name":"js","slug":"js","permalink":"http://izqcool.com/tags/js/"}]},{"title":"Hexo:使用心得","date":"2016-03-18T11:27:12.000Z","path":"2016/03/18/hexo-使用心得/","text":"Hexo是一款简单、快速、强大的Node.js静态博客框架,它具有以下特点: 快速 Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 撰写流畅 支持GitHub Flavored Markdown和所有Octopress的插件。 扩展性好 Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less。 基于以上特点，Hexo得到了很多程序猿的青睐，网上关于Hexo的教程更是不胜枚举。博主本次对网上一些比较好的资源进行了梳理，内容如下: 入门: 如何搭建一个独立博客——简明Github Pages与Hexo教程 Hexo基本用法 hexo你的博客 进阶: Hexo高级进阶 如果读者想自己编写模块，可以仔细研究下 关于主题:Hexo的主题配置相当简单，博主就不一一细说了，直接给链接，读者喜欢神马风格自己去挑选吧，强烈推荐Next，使用文档相对完整，方便大家配置当然，作为一名程序猿，没有自己风格的博客的确不太好，自己写主题模板什么的想干就干吧，欢迎大家一起交流，博主的模板正在制作ing，敬请期待。。。。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://izqcool.com/tags/Hexo/"}]}]