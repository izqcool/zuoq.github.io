[{"title":"关于React.js的基本概念都在这篇文章中","date":"2018-03-07T15:06:14.000Z","path":"2018/03/07/关于React.js的基本概念都在这篇文章中/","text":"去年我写了一本差不多一百来页关于React的书，今年，我将挑战自己，将其归纳为一片文章。 本文不会介绍React以及你为什么应该学习它,而是对那些已经熟悉JavaScript并了解DOM API的开发人员的React.js知识的介绍。 下面所有示例的代码都会都有标注以供参考。它们纯粹是为了示例，大多数都可以有更好的写法。 一、 React 是基于组件的 React是基于可重用组件的概念而设计的，你定义一些小的组件并将它们组合成打的组件。 所有的组件都是可复用的，即使放在不同的项目中也是如此。 React组件最简单的形式是一个JavaScript函数。 12345678// Example 1// https://jscomplete.com/repl?j=Sy3QAdKHWfunction Button (props) &#123; // Returns a DOM element here. For example: return &lt;button type=\"submit\"&gt;&#123;props.label&#125;&lt;/button&gt;;&#125;// To render the Button component to the browserReactDOM.render(&lt;Button label=\"Save\" /&gt;, mountNode) 下面介绍用于按钮标签的花括号。 你现在不需要考虑他们， ReactDOM也会在后面解释，但如果你想测试这个例子和所有接下来的示例代码，上面的渲染函数就是你所需要的。 ReactDOM.render的第二个参数是插入模板的目标位置（DOM节点），在 jsComplete React Playground中，你可以使用特殊的变量mountNode。 关于示例1有以下几点需要注意： 组件名称以大写字母开头。这样做是必须的，可以避免HTML元素和React元素的混淆。小写字母开头是为HTML元素保留的，如果尝试命名React组件的名称为“button”,你会发现ReactDOM将会忽略该函数并呈现一个常规的空HTML按钮。 和HTML元素一样，每个组件都还可以接受一个属性列表。在React中，这个属性被称为props,你可以随意命名它。 在上面的Button函数组件的返回输出中编写了类似HTML的代码， 但这既不是JavaScript也不是HTML，甚至不是React.js。但是，它非常流行，因此它成为了React应用程序的默认设置。，它被称为JSX，它是一个JavaScript扩展。 二、 什么是JSX？上面的示例1可以在没有JSX的纯React.js中编写，如下所示：1234567891011121314// Example 2 - React component without JSX// https://jscomplete.com/repl?j=HyiEwoYB-function Button (props) &#123; return React.createElement( \"button\", &#123; type: \"submit\" &#125;, props.label );&#125;// To use Button, you would do something likeReactDOM.render( React.createElement(Button, &#123; label: \"Save\" &#125;), mountNode); createElement函数是React主要的API。它是你需要学习的8个重要的API中的一个，没错，React中的API就是这么的少。 就像DOM本身有一个document.createElement函数来创建一个由标签名称指定的元素一样，React的createElement函数是一个可以执行document.createElement的高级函数，但它也可以用来创建一个元素来表示一个React组件。创建上面例2中的Button组件时，就是后者的体现。 与document.createElement不同，React的createElement接受第二个参数后的动态数量的参数来表示创建的元素的子元素。 所以createElement实际上创建了一棵树。 这里有一个例子：12345678910111213141516171819// Example 3 - React’s createElement API// https://jscomplete.com/repl?j=r1GNoiFBbconst InputForm = React.createElement( \"form\", &#123; target: \"_blank\", action: \"https://google.com/search\" &#125;, React.createElement(\"div\", null, \"Enter input and click Search\"), React.createElement(\"input\", &#123; name: \"q\", className: \"input\" &#125;), React.createElement(Button, &#123; label: \"Search\" &#125;));// InputForm uses the Button component, so we need that too:function Button (props) &#123; return React.createElement( \"button\", &#123; type: \"submit\" &#125;, props.label );&#125;// Then we can use InputForm directly with .renderReactDOM.render(InputForm, mountNode); 上面的示例有一下需要注意的地方： InputForm不是一个React组件; 它只是一个React元素。 这就是为什么我们直接在ReactDOM.render调用中使用它，而不是使用&lt;InputForm/&gt; React.createElement函数在接受了多个参数。 它从第三个参数开始的参数列表包含创建元素的子项列表。 我们能够嵌套React.createElement调用，因为它全部是JavaScript。 当元素不需要属性或props时，React.createElement的第二个参数可以为null或空对象。 我们可以将HTML元素与React元素混合使用。 React的API试图尽可能地接近DOM API，这就是为什么我们使用className而不是class作为input元素的原因。我们都希望React的API成为DOM API本身的一部分， 因为，它比DOM API 更好。 上面的代码是基于你在包含React库时浏览器可以理解的内容， 浏览器不处理任何JSX业务。然而，我们喜欢看到和使用HTML而不是这些createElement调用（想象一下你用document.createElement构建一个网站）。这就是JSX存在的原因， 与使用React.createElement编写上述表单不同，我们可以使用与HTML非常相似的语法编写它： 12345678910111213141516// Example 4 - JSX (compare with Example 3)// https://jscomplete.com/repl?j=SJWy3otHWconst InputForm = &lt;form target=\"_blank\" action=\"https://google.com/search\"&gt; &lt;div&gt;Enter input and click Search&lt;/div&gt; &lt;input name=\"q\" className=\"input\" /&gt; &lt;Button label=\"Search\" /&gt; &lt;/form&gt;;// InputForm \"still\" uses the Button component, so we need that too.// Either JSX or normal form would dofunction Button (props) &#123; // Returns a DOM element here. For example: return &lt;button type=\"submit\"&gt;&#123;props.label&#125;&lt;/button&gt;;&#125;// Then we can use InputForm directly with .renderReactDOM.render(InputForm, mountNode); 请注意以下几点： 它并不是HTML。 例如，我们仍然在使用className而不是class。 我们仍在考虑JavaScript上的HTML如上所示。 看看我如何在最后添加分号。 我们上面写的（例4）是JSX。 然而，我们对浏览器采取的是它的编译版本（例3）。 为了实现这一点，我们需要使用预处理器将JSX版本转换为React.createElement版本。 这就是JSX。 这是一个折中的方案，它允许我们用类似于HTML的语法编写我们的React组件，这是一种相当不错的方式。 顺便提一下，JSX可以独立使用。它不是React的特有的语法。 三、您可以在JSX中的任何地方使用JavaScript表达式在JSX中，您可以在一对大括号内使用任何JavaScript表达式。12345678// Example 5 - Using JavaScript expressions in JSX// https://jscomplete.com/repl?j=SkNN3oYSWconst RandomValue = () =&gt; &lt;div&gt; &#123; Math.floor(Math.random() * 100) &#125; &lt;/div&gt;;// To use it:ReactDOM.render(&lt;RandomValue /&gt;, mountNode); 任何JavaScript表达式都可以放在大括号内。 这相当于JavaScript模板文字中的$ {}插值语法。 这是JSX内唯一的约束：只有表达式。 因此，您不能使用常规if语句，但三元表达式可以。 JavaScript变量也是表达式，所以当组件接收到一个props列表（RandomValue组件没有，props是可选的）时，你可以在花括号中使用这些props。 我们在上面的Button组件中这样做过（例1）。 JavaScript对象也是表达式。 有时我们在花括号内使用JavaScript对象，这使得它看起来像双花括号，但它实际上只是一个花括号内的对象。 一个视力是将一个CSS样式对象传递给React中的特殊样式属性： 12345678910111213// Example 6 - An object passed to the special React style prop// https://jscomplete.com/repl?j=S1Kw2sFHbconst ErrorDisplay = (&#123;message&#125;) =&gt; &lt;div style=&#123; &#123; color: 'red', backgroundColor: 'yellow' &#125; &#125;&gt; &#123;message&#125; &lt;/div&gt;;// Use it:ReactDOM.render( &lt;ErrorDisplay message=\"These aren't the droids you're looking for\" /&gt;, mountNode); 请注意，我是如何将props中的message解构出来的。 还要注意上面的style属性是如何特殊的（同样，它不是HTML，它更接近于DOM API）。 我们使用一个对象作为style属性的值。 该对象定义了样式，就好像我们在JavaScript中那样。 你甚至可以在JSX中使用React元素，因为这也是一个表达式。 请记住，React元素本质上是一个函数调用： 12345678910111213141516171819// Example 7 - Using a React element within &#123;&#125;// https://jscomplete.com/repl?j=SkTLpjYr-const MaybeError = (&#123;errorMessage&#125;) =&gt; &lt;div&gt; &#123;errorMessage &amp;&amp; &lt;ErrorDisplay message=&#123;errorMessage&#125; /&gt;&#125; &lt;/div&gt;; // The MaybeError component uses the ErrorDisplay component:const ErrorDisplay = (&#123;message&#125;) =&gt; &lt;div style=&#123; &#123; color: 'red', backgroundColor: 'yellow' &#125; &#125;&gt; &#123;message&#125; &lt;/div&gt;;// Now we can use the MaybeError component:ReactDOM.render( &lt;MaybeError errorMessage=&#123;Math.random() &gt; 0.5 ? 'Not good' : ''&#125; /&gt;, mountNode); 如果传递给它的errorMessage字符串和空div，上面的MaybeError组件将只显示ErrorDisplay组件。 React认为{true}，{false}，{undefined}和{null}是有效的元素子元素，它们不会呈现任何内容。 你也可以在JSX中使用JavaScript函数，例如（map, reduce, filter, concat等）：12345678// Example 8 - Using an array map inside &#123;&#125;// https://jscomplete.com/repl?j=SJ29aiYH-const Doubler = (&#123;value=[1, 2, 3]&#125;) =&gt; &lt;div&gt; &#123;value.map(e =&gt; e * 2)&#125; &lt;/div&gt;;// Use itReactDOM.render(&lt;Doubler /&gt;, mountNode); 请注意我是如何通过设置默认的prop来获取value的，同时也注意我在div内使用了箭头函数，react支持这样的语法，文本节点中将插入翻倍的value值。 四、你可以使用class编写react组件用函数编写组件非常适合简单的需求，但是有时候我们会面对更为复杂的场景。React支出使用JavaScript的class语法构建组件，我们使用class语法将例一中的Botton组件改写为如下所示：123456789// Example 9 - Creating components using JavaScript classes// https://jscomplete.com/repl?j=ryjk0iKHbclass Button extends React.Component &#123; render() &#123; return &lt;button&gt;&#123;this.props.label&#125;&lt;/button&gt;; &#125;&#125;// Use it (same syntax)ReactDOM.render(&lt;Button label=\"Save\" /&gt;, mountNode); class的语法很简单，它定义一个继承至React.Component类（有一个你需要学习的React API），该类定义了单个实例函数rengde()，并且render函数返回虚拟DOM元素。每次当我们使用这个基于类的Button组件时（例如，通过执行），React将实例化一个对象，该对象在DOM树中渲染DOM元素。 这就是为什么我们在上面呈现的输出中在JSX中使用this.props.label的原因。因为通过类组件呈现的每个元素都会获取一个名为props的特殊实例属性，该属性保存创建时传递给该元素的所有值。 由于我们每次调用组件时都会生成一个实例，所以我们可以根据需要自定义该实例。 例如，我们可以在通过使用常规JavaScript构造函数构造它对其进行自定义：12345678910111213// Example 10 - Customizing a component instance// https://jscomplete.com/repl?j=rko7RsKS-class Button extends React.Component &#123; constructor(props) &#123; super(props); this.id = Date.now(); &#125; render() &#123; return &lt;button id=&#123;this.id&#125;&gt;&#123;this.props.label&#125;&lt;/button&gt;; &#125;&#125;// Use itReactDOM.render(&lt;Button label=\"Save\" /&gt;, mountNode); 我们还可以定义类函数并在我们希望的任何地方使用它们，甚至是在返回的JSX输出中：123456789101112131415161718// Example 11 — Using class properties// https://jscomplete.com/repl?j=H1YDCoFSbclass Button extends React.Component &#123; clickCounter = 0; handleClick = () =&gt; &#123; console.log(`Clicked: $&#123;++this.clickCounter&#125;`); &#125;; render() &#123; return ( &lt;button id=&#123;this.id&#125; onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.label&#125; &lt;/button&gt; ); &#125;&#125;// Use itReactDOM.render(&lt;Button label=\"Save\" /&gt;, mountNode); 关于例11，有以下几点需要注意： handleClick函数是使用JavaScript中新建议的类字段语法编写的，但由于许多原因，这是访问组件实例的最佳选择（感谢箭头功能），但是你需要项Babel这样的编译器来编译它。 我们还使用相同的类字段语法定义了clickCounter实例变量。 当我们将handleClick函数指定为特殊的onClick React属性的值时，我们没有调用它。 我们传递了对handleClick函数的引用。 在这里直接调用函数是使用React时最常见的错误之一。1234// Wrong:onClick=&#123;this.handleClick()&#125;// Right:onClick=&#123;this.handleClick&#125;","tags":[{"name":"react 翻译","slug":"react-翻译","permalink":"http://izqcool.com/tags/react-翻译/"}]},{"title":"","date":"2018-02-05T03:02:48.000Z","path":"2018/02/05/在javascript中使用undefined的七个技巧/","text":"在JavaScript中使用undefined的七个技巧 在最近的开发中，遇到了很多数据逻辑处理的问题，涉及到了大量的判断，经常要对请求返回的数据做异常判断，在根据数据渲染视图时，大量的undefined判断让人很难受，正巧发现了这篇很不错的文章，将它翻译出来。 当我在八年之前学习JavaScript的时候，undefinded和null都表示“空值”让我很费解，它们的具体差异是什么？它们看上去都定义了“空值”，并且undefined==null的结果为true. 像Ruby，Python或Java等大多数语言都有一个空值（零或空），这似乎是一个合理的方法; 在JavaScript中，当访问尚未初始化的变量或对象属性时，解释器返回undefined。 例如： 1234let company; company; // =&gt; undefined let person = &#123; name: 'John Smith' &#125;; person.age; // =&gt; undefined","tags":[]},{"title":"ES6重要知识总结","date":"2017-08-05T14:36:14.000Z","path":"2017/08/05/ES6重要知识总结/","text":"1 let和const 共同点： 不存在变量提升，作用在块级作用域，不允许重复声明。 不同点 const必须在声明的时候就赋值，声明过后不能重新赋值。 2 解构赋值 通过解析解构来赋值，和就够相相应的赋值形式，存在一下好处： (1) 指定默认值（函数，对象等）； (2) 不引入其他变量方便的交换变量的值； (3) 方便的接受函数的返回值（当返回是对象的时候） (4) 是json的处理更加简洁 (5) 制定输入模块的方法 3 字符窜扩展 使用 `` 代替 “”， 使用${}在字符窜中嵌入变量，不再使用+号连接字符窜。 4 函数扩展 参数默认值的设置： es6可以直接对函数的参数设置默认值，eg: 123456789function test(x=1,y=2) &#123; console.log(x,y);&#125;test(); //1,2test(4,5); //4,5test(4); //4,2test( ,5) //报错test(undefined,5); //1,5// 默认参数一般放在最后，只有最后一个默认参数在传参的时候可以省略，否则会报错， 如果想要使用默认参数，可以传入“unfefined”； length属性失真： 制定了默认参数后，函数的length属性将发生变化，length变为第一个默认参数之前的参数个数，eg： 123(function(x=1,y=2)&#123;&#125;).length; //0(function(x,y,z=1)&#123;&#125;).length; //2(function(x,y=1,z,m=2)&#123;&#125;).length; //1 作用域（参数作用域）： 指定了默认参数后，参数会形成一个单独的作用域，eg: 12345678910111213const x=3;function test(x,y=x) &#123; console.log(y);&#125;test(4); // 4//在参数空间内，y的值由x赋给，此时x的值是4，所以y输出4；const z = 4;function test1(z=z)&#123; console.log(z);&#125;test1(); // ReferenceError: z is not defined//在调用test1()的时候没用传参，这时参数z的值并没有从全局变量中去寻找，可见参数作用域是一个特定的作用域。 箭头函数 : 箭头函数是使用 “=&gt;“的一种函数写法，可以使函数的书写更加简介，它具有以下特点： (1) 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分，eg： 1234567891011const showName = () =&gt; \"izqcool\";//等价于const showName = fuction() &#123; return \"izqcool\";&#125;const add = (num1,num2) =&gt; num1+num2;//等价于const add = function(num1,num2) &#123; return num1+num2;&#125; (2) 函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回，eg： 1234const add = (num1,num2) =&gt; &#123; const sum = num1+num2; return sum;&#125;; (3) 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，eg： 1const getItem = (id) =&gt; (&#123;id:id,name:\"izqcool\"&#125;); (4) 可以与变量解构结合使用： 12345const getName = (&#123;firstName,lastName&#125;) =&gt; firsrName + \" \" + lastName;//等价于const getName = function(person)&#123; return person.firstName + \" \" + person.lastName;&#125; (5) 箭头函数的this对象: （箭头函数的this对象指向的是定义时的对象，而不是调用的对象）,eg： 123456789101112131415161718function Timer() &#123; this.s1 = 0; this.s2 = 0; setInterval(() =&gt; this.s1++,1000); setInterval(function()&#123; this.s2++; &#125;,1000)&#125;const timer = new Timer();setTimeout(()=&gt;&#123; console.log(\"s1:\"+timer.s1);&#125;,3100);//s1:3setTimeout(()=&gt;&#123; console.log(\"s2:\"+timer.s2);&#125;,3100);//s2:0 ###5 module 语法及加载机制： 1 输入模块 import1234567import &#123; stat, exists, readFile &#125; from 'fs';//从fs模块加载以上3个方法，其余的不加载（如果有） 加载方式为静态加载（编译时加载）import &#123; stat as xxx &#125; from './fs';//将stat定义为别名xxximport * as xxx from './fs';//加载所有并定义为别名xxx 1.2 模块对外接口 export12345678910111213141516const A = 1;const B = 2;const C = 3;//输出A,B,Bexport &#123;A,B,C&#125;;//指定别名输出A,B,Cexport &#123; A as nameA, B as nameB, C as nameC&#125;;//默认输出(只能有一个)export default 2 加载机制 es6的模块引用是动态加载的，import加载的是值引用（不是值的拷贝），脚本执行时，根据引用到被加载的模块去取值，被加载模块内部的变化会体现在加载的模块里，所以说是“活的”。","tags":[{"name":"ES6 总结","slug":"ES6-总结","permalink":"http://izqcool.com/tags/ES6-总结/"}]},{"title":"2017,新的开始","date":"2017-01-01T14:16:26.000Z","path":"2017/01/01/2017-新的开始/","text":"写在开头： 阳历新年的第一天，很有必要写点东西来开始我人生中新的一年，因为我知道，这必然是不平凡的一年，我希2017年我能过得更好，当我在年终总结的时候，我没有遗憾，对得起我人生中的这充满期盼的一年。 回首过去：2016年过得平平淡淡，大部分时间和以前都差不多，九月和十月是唯一的插曲，身边的人大多数要么在努力找工作，要么奋斗在图书馆的考研路上。自己还是比较幸运，没用太多的时间找到了自己想要的工作，虽然不是最理想，但也说得上满意。如果说有遗憾，那就是对自己要其实的不高，浪费了太多的时间，没有是自己变得优秀。 展望未来：2017注定会有很多不舍和波折，对离校的不舍，多社会的适应，我不敢去奢求每一件事都完美，但是我可以让自己变得更好： 1. 尽可能让自己的github多绿一些 2. 多看书，升华自己 3. 对得起身边的每一个人 最后，对自己说一句，加油，期待2017愈发优秀的自己！！！","tags":[{"name":"记录 生活","slug":"记录-生活","permalink":"http://izqcool.com/tags/记录-生活/"}]},{"title":"Js中this关键字","date":"2016-09-11T02:52:03.000Z","path":"2016/09/11/js中this关键字/","text":"js中的this关键字的只想问题是容易出错地方，很多初学者在面对this关键字时摸不着头脑。其实this关键字并不是无章可循，弄清楚这个函数或者方法是谁调用的，this的指向就是谁，下面给出常见的几种调用方法。 函数的调用方式有以下几种： 普通函数调用 作为方法来调用 作为构造函数来调用 使用apply/call方法来调用 Function.prototype.bind方法 es6箭头函数 普通函数的调用：12345678function test() &#123; this.name = \"izqcool\"; console.log(this); console.log(this.name); &#125;test(); // 输出为： Window izqcoolwindow.test(); // 输出为： Window izqcoolconsole.log(window.name); //izqcool 上面的代码test函数先作为普通，实际上test是作为全局对象window的一个方法来调用，即window.test(),所以二者输出结果完全相同，此时是window对象调用了test方法，test函数中的this就指向window,test函数中的this.name=”izqcool”等价于window.name = “izqcool”,所以window获得了name的值为izqcool的属性； 将代码作以下修改：12345vae name = \"izqcool_test\";function test() &#123; console.log(this.name);&#125;test(); //输出: izqcool_test 同样这个地方test作为window的方法来调用，在代码的一开始定义了一个全局变量name，值为izqcool_test,它相当于window的一个属性,即window.name=”izqcool_test”,又因为在调用test的时候this是指向window的，因此这里会输出izqcool_test. 作为方法调用:严格来说，上面的示例test函数也是作为方法来调用的，test函数是window的方法，this指向了window。 我们再来看一个直观的例子：1234567891011121314var name = \"izqcool_test\";var test = &#123; name : \"izqcool\", showName : function() &#123; console.log(this.name); &#125;&#125;;test.showName(); //输出: izqcool//此处是test对象调用showName方法，所以this关键字是指向test对象的，test对象的name值为所以输出izqcoolvar showName_another = test.showName;showName_another(); //输出： izqcool_test //这里将test.showName方法赋给showName_another变量，此时showName_another变量相当于window对象的一个属性，因此showName_another()执行的时候相当于window.showName_another,即window对象调用showName_another这个方法，所以this关键字指向window,输出为izqcool_test 再换一种形式：1234567891011121314var test_1 = &#123; name : \"izqcool_1\", showName : function() &#123; console.log(this.name); &#125;&#125;;var test_2 = &#123; name : \"izqcool_2\", sayName : test_1.showName;&#125;;test_2.sayName(); //输出: izqcool_2;//虽然showName这个方法是在test_1中定义的，但是缺是被test_2调用的，可见在哪里声明并不重要，关键还是要看被谁调用。 作为构造函数调用:1234567891011function Test(name) &#123; this.name = name;&#125;var test_1 = Test(\"izqcool\");console.log(test_1.name); // 输出： 报错console.log(window.name); // 输出： izqcool//上述代码没有进行new操作符，将Test函数直接调用，相当于window对象调用Test(),this指向window,所以window.name输出为izqcool。var test_2 = new Test(\"izqcool\");consoel.log(test_2.name); //输出: izqcool 关于构造函数，我会在之后写一篇文章详细介绍。 call/apply方法的调用call/apply方法可以用来改变this关键字的指向： Object.method.apply(AnotherObj,arguments);123456789var name = \"izqcool\";var Test = &#123; name : \"izqcool_test\", showName : function() &#123; console.log(this.name); &#125;&#125;;Test.showName.call(); //输出： izqcool //call方法的第一个参数为空时，默认为window,使用call方法后，showName方法内的this指向了window，故输出为izqcool. Function.prototype.bind()方法123456789101112var name = \"izqcool\";function Test(name) &#123; this.name = name; this.sayName = function() &#123; setTimeout(function()&#123; console.log(\"my name is:\" + this.name); &#125;,100); &#125;&#125;var test = new Test(\"izqcool_test\");test.sayName(); //输出: my name is: izqcool//这里的setTimeout()函数，相当于window.setTimeout(),由window这个全局对象调用，因此输出为izqcool,而不是izqcool_test。 那么如何才能实现输出izqcool_test呢？123456789101112var name = \"izqcool\";function Test(name) &#123; this.name = name; this.sayName = function() &#123; setTimeout(function()&#123; console.log(\"my name is:\" + this.name); &#125;.bind(this),100); //这里使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Test对象 &#125;&#125;var test = newTest(\"izqcool_test\");test.sayName(); //输出: my name is: izqcool_test//这里的setTimeout()函数，相当于window.setTimeout(),由window这个全局对象调用，因此输出为izqcool,而不是izqcool_test。 需要注意的是： setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。在《javascript高级程序设计》当中，写到：“超时调用的代码(setTimeout)都是在全局作用域中执行的，因此函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined”。本文都是在非严格模式下的情况。 上面的例子也可以写成这样：12345678910111213var name = \"izqcool\";function Test(name) &#123; var that = this; this.name = name; this.sayName = function() &#123; setTimeout(function()&#123; console.log(\"my name is:\" + that.name); &#125;,100); &#125;&#125;var test = newTest(\"izqcool_test\");test.sayName(); //输出: my name is: izqcool_test//先将this值赋给了that，这样that保存的是Test对象，访问that.name时，取到的值是Test.name的值。 ES6箭头函数：在ES6中，this指向是固定的，始终指向外部对象，因为箭头函数没有this,因此它自身不能进行new实例化,同时也不能使用call, apply, bind等方法来改变this的指向 12345678910111213141516function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100); //输出 s1: 3setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100); //输出 s2: 0 面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。 结语：js中this的指向问题我们不要关注函数是在哪里申明的，而要看是在哪里调用的，在平时的编码过程中多分析，多测试，掌握起来应该不是什么难事。","tags":[{"name":"js","slug":"js","permalink":"http://izqcool.com/tags/js/"}]},{"title":"暑期总结","date":"2016-08-28T06:38:14.000Z","path":"2016/08/28/暑期总结/","text":"不知不觉间大三暑假马上就要结束了，原本打算暑假找一份实习锻炼下自己这一年多的学习成果，可是由于一些原因最终没能出去实习，实在是很遗憾。但是多少还是有一些收获，接受过几次面试，对自己目前的能力有了比较清晰的认识，记录下来，鞭策自己。 印象最深的两次面试 北京某公司 一家创业公司，前端团队人数不多，虽然没去公司面试，但是面试官和负责任，可以看出面试内容是经过精心准备的，考察的知识点很细节。这次面试让我深刻认识到自己的基础知识还存在很多的不足，尤其是CSS部分。另外，面试官给出了很多自己学习的经验，推荐了很不错的方法，令我受益匪浅。 阿里 面的是阿里的内推，阿里的面试很少问细节的东西，更多的是对技术的理解。 第一次接面试电话的时候，面试官只是了解了基本情况，然后让我写一份自己的技术栈架整理和自己的学习路线，然后第二天针对自己的整理进行面试。当时我的整理中提到了vue和avalon框架，面试官针对框架的之间差异提问，让我对比两个框架的特点，一些功能的实现方式，我回答的不是很理想，面试官建议我去多看一些源码，学会归纳对比，要对自己的技术栈有一个明确的认识。 两次的面试各有偏重点，但对我今后的学习却很有帮助。今后要多谢博客，记录整理自己所学，谨以此篇开始记录之路。","tags":[{"name":"总结","slug":"总结","permalink":"http://izqcool.com/tags/总结/"}]},{"title":"Js作用域与作用域链","date":"2016-05-13T12:50:59.000Z","path":"2016/05/13/js作用域与作用域链/","text":"导语： 在JavaScript的学习中，作用域和作用域链是非常重要的两个基础概念，理解好这两个概念对我们掌握变量提升、闭包等概念有很大的帮助。 作用域： 概念： 变量和函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。 分类： 全局作用域：（在代码的任何地方都可以访问到）： 1.所有未定义直接赋值的变量会自动生命为全局作用域 2.所有window对象的属性 局部作用域：（只用在固定的代码片段中可以访问，常见于函数内部，习惯叫做函数作用域） 注意： js里是是没有块级作用域的，定义在for()循环内的变量能够在for()循环外访问到：1234for(var i=0;i&lt;10;i++) &#123; var color = \"blue\";&#125; console.log(color); 输出结果为blue,可见可以访问到代码块内声明的变量。 作用域链： 全局变量在程序中始终是有定义的。局部变量在声明它的函数体内以及它所嵌套的函数内始终是有定义的。这句话准确的定义了作用域链，但是对于初学者来说会有点难以理解。下面是我对作用域链的简单理解： JavaScript有一个内部属性称为Scope，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。 如下面这张图： 1，2，3分别表示3个不同的作用域，在这3个作用域中，他们彼此独立，互不干扰，函数1不能访问定义在函数2和3中的变量，也就是说定义在函数内部的变量只对这个的函数生效，其他函数是无法使用这个变量的。（当然，这只是针对相互对立的函数，嵌套函数不是这样）。 对于含有嵌套关系的函数，像上图3中这样，就会遵循作用域链规则，我们把它单独拿出来讲解，如下图所示： 对应的，我们看下面这段代码： 1234567891011121314151617181920var global1 = 'global1';var global2 = 'global2';function fn1() &#123; var a = 1; function fn2() &#123; var b = 2; function fn3() &#123; var c = 3; var global2 = 'another global2'; console.log(c); console.log(b); console.log(a); console.log(global1); console.log(global2); &#125; fn3(); &#125; fn2();&#125;fn1(); 上面代码对应的输出结果依次为3，2，1，global1，another global2; 可以看到，在最内层的函数中，我们可以访问外层定义的变量。它的工作过程基于作用域链，在嵌套函数中，当变量本层函数中未定义时，会向外层寻找，若找到就结束，使用找到的变量，找不到就继续，当在全局变量中还是找不到时，就会报错。我将这种机制称为由内而外，就近原则，由内而外就是上图所的向外层寻找，函数fn3可以找到外层函数fn2定义的变量b，而反过来函数fn2却不能使用变量c；就近原则和我们在英语学习中的就近原则是一个意思，就是选择最近的一个，上面的例子中，分别在函数fn3和全局对象中定义了global2,但是在由内而外寻找时，最先寻找的是在fn3内定义的，所以就终止寻找，最终输出的global2的结果为another global2而不是global2。","tags":[{"name":"js","slug":"js","permalink":"http://izqcool.com/tags/js/"}]},{"title":"Hexo:使用心得","date":"2016-03-18T11:27:12.000Z","path":"2016/03/18/hexo-使用心得/","text":"Hexo是一款简单、快速、强大的Node.js静态博客框架,它具有以下特点: 快速 Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 撰写流畅 支持GitHub Flavored Markdown和所有Octopress的插件。 扩展性好 Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less。 基于以上特点，Hexo得到了很多程序猿的青睐，网上关于Hexo的教程更是不胜枚举。博主本次对网上一些比较好的资源进行了梳理，内容如下: 入门: 如何搭建一个独立博客——简明Github Pages与Hexo教程 Hexo基本用法 hexo你的博客 进阶: Hexo高级进阶 如果读者想自己编写模块，可以仔细研究下 关于主题:Hexo的主题配置相当简单，博主就不一一细说了，直接给链接，读者喜欢神马风格自己去挑选吧，强烈推荐Next，使用文档相对完整，方便大家配置当然，作为一名程序猿，没有自己风格的博客的确不太好，自己写主题模板什么的想干就干吧，欢迎大家一起交流，博主的模板正在制作ing，敬请期待。。。。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://izqcool.com/tags/Hexo/"}]}]